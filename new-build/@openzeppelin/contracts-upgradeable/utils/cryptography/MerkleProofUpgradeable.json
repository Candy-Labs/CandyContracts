{"abi":[],"devdoc":{"details":"These functions deal with verification of Merkle Trees proofs. The proofs can be generated using the JavaScript library https://github.com/miguelmota/merkletreejs[merkletreejs]. Note: the hashing algorithm should be keccak256 and pair sorting should be enabled. See `test/utils/cryptography/MerkleProof.test.js` for some examples.","kind":"dev","methods":{},"version":1},"evm":{"assembly":"    /* \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\":508:2297  library MerkleProofUpgradeable {... */\n  dataSize(sub_0)\n  dataOffset(sub_0)\n  0x0b\n  dup3\n  dup3\n  dup3\n  codecopy\n  dup1\n  mload\n  0x00\n  byte\n  0x73\n  eq\n  tag_1\n  jumpi\n  mstore(0x00, shl(0xe0, 0x4e487b71))\n  mstore(0x04, 0x00)\n  revert(0x00, 0x24)\ntag_1:\n  mstore(0x00, address)\n  0x73\n  dup2\n  mstore8\n  dup3\n  dup2\n  return\nstop\n\nsub_0: assembly {\n        /* \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\":508:2297  library MerkleProofUpgradeable {... */\n      eq(address, deployTimeAddress())\n      mstore(0x40, 0x80)\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa2646970667358221220ef3ef74ad1d820d26765d8f112cab9b4c5f244c4f644d3e78c6408d1b59aabf564736f6c634300080d0033\n}\n","bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ef3ef74ad1d820d26765d8f112cab9b4c5f244c4f644d3e78c6408d1b59aabf564736f6c634300080d0033","opcodes":"PUSH1 0x56 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xEF RETURNDATACOPY 0xF7 0x4A 0xD1 0xD8 KECCAK256 0xD2 PUSH8 0x65D8F112CAB9B4C5 CALLCODE DIFFICULTY 0xC4 0xF6 DIFFICULTY 0xD3 0xE7 DUP13 PUSH5 0x8D1B59AAB CREATE2 PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ","sourceMap":"508:1789:10:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;508:1789:10;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ef3ef74ad1d820d26765d8f112cab9b4c5f244c4f644d3e78c6408d1b59aabf564736f6c634300080d0033","opcodes":"PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xEF RETURNDATACOPY 0xF7 0x4A 0xD1 0xD8 KECCAK256 0xD2 PUSH8 0x65D8F112CAB9B4C5 CALLCODE DIFFICULTY 0xC4 0xF6 DIFFICULTY 0xD3 0xE7 DUP13 PUSH5 0x8D1B59AAB CREATE2 PUSH5 0x736F6C6343 STOP ADDMOD 0xD STOP CALLER ","sourceMap":"508:1789:10:-:0;;;;;;;;"},"gasEstimates":{"creation":{"codeDepositCost":"17200","executionCost":"103","totalCost":"17303"},"internal":{"_efficientHash(bytes32,bytes32)":"infinite","processProof(bytes32[] memory,bytes32)":"infinite","verify(bytes32[] memory,bytes32,bytes32)":"infinite"}},"legacyAssembly":{".code":[{"begin":508,"end":2297,"name":"PUSH #[$]","source":10,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":508,"end":2297,"name":"PUSH [$]","source":10,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"B"},{"begin":508,"end":2297,"name":"DUP3","source":10},{"begin":508,"end":2297,"name":"DUP3","source":10},{"begin":508,"end":2297,"name":"DUP3","source":10},{"begin":508,"end":2297,"name":"CODECOPY","source":10},{"begin":508,"end":2297,"name":"DUP1","source":10},{"begin":508,"end":2297,"name":"MLOAD","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"BYTE","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"73"},{"begin":508,"end":2297,"name":"EQ","source":10},{"begin":508,"end":2297,"name":"PUSH [tag]","source":10,"value":"1"},{"begin":508,"end":2297,"name":"JUMPI","source":10},{"begin":-1,"end":-1,"name":"PUSH","source":-1,"value":"4E487B71"},{"begin":-1,"end":-1,"name":"PUSH","source":-1,"value":"E0"},{"begin":-1,"end":-1,"name":"SHL","source":-1},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"MSTORE","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"4"},{"begin":508,"end":2297,"name":"MSTORE","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"24"},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"REVERT","source":10},{"begin":508,"end":2297,"name":"tag","source":10,"value":"1"},{"begin":508,"end":2297,"name":"JUMPDEST","source":10},{"begin":508,"end":2297,"name":"ADDRESS","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"MSTORE","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"73"},{"begin":508,"end":2297,"name":"DUP2","source":10},{"begin":508,"end":2297,"name":"MSTORE8","source":10},{"begin":508,"end":2297,"name":"DUP3","source":10},{"begin":508,"end":2297,"name":"DUP2","source":10},{"begin":508,"end":2297,"name":"RETURN","source":10}],".data":{"0":{".auxdata":"a2646970667358221220ef3ef74ad1d820d26765d8f112cab9b4c5f244c4f644d3e78c6408d1b59aabf564736f6c634300080d0033",".code":[{"begin":508,"end":2297,"name":"PUSHDEPLOYADDRESS","source":10},{"begin":508,"end":2297,"name":"ADDRESS","source":10},{"begin":508,"end":2297,"name":"EQ","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"80"},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"40"},{"begin":508,"end":2297,"name":"MSTORE","source":10},{"begin":508,"end":2297,"name":"PUSH","source":10,"value":"0"},{"begin":508,"end":2297,"name":"DUP1","source":10},{"begin":508,"end":2297,"name":"REVERT","source":10}]}}},"methodIdentifiers":{}},"ewasm":{"wasm":""},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"These functions deal with verification of Merkle Trees proofs. The proofs can be generated using the JavaScript library https://github.com/miguelmota/merkletreejs[merkletreejs]. Note: the hashing algorithm should be keccak256 and pair sorting should be enabled. See `test/utils/cryptography/MerkleProof.test.js` for some examples.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\":\"MerkleProofUpgradeable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x00d8f573e13de0ecde43557f5d246a322bc284ef644d9437d9bb8cb9a6eac265\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}
