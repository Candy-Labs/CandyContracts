{"abi":[],"devdoc":{"details":"https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as \"clones\". > To simply and cheaply clone contract functionality in an immutable way, this standard specifies > a minimal bytecode implementation that delegates all calls to a known, fixed address. The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2` (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the deterministic method. _Available since v3.4._","kind":"dev","methods":{},"version":1},"evm":{"assembly":"    /* \"@openzeppelin/contracts/proxy/Clones.sol\":740:3557  library Clones {... */\n  dataSize(sub_0)\n  dataOffset(sub_0)\n  0x0b\n  dup3\n  dup3\n  dup3\n  codecopy\n  dup1\n  mload\n  0x00\n  byte\n  0x73\n  eq\n  tag_1\n  jumpi\n  mstore(0x00, shl(0xe0, 0x4e487b71))\n  mstore(0x04, 0x00)\n  revert(0x00, 0x24)\ntag_1:\n  mstore(0x00, address)\n  0x73\n  dup2\n  mstore8\n  dup3\n  dup2\n  return\nstop\n\nsub_0: assembly {\n        /* \"@openzeppelin/contracts/proxy/Clones.sol\":740:3557  library Clones {... */\n      eq(address, deployTimeAddress())\n      mstore(0x40, 0x80)\n      0x00\n      dup1\n      revert\n\n    auxdata: 0xa2646970667358221220a5ae41e3121efb1e2bae5441e2ce40ec752f4c9a3f9c958ac15520844a50473764736f6c634300080d0033\n}\n","bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a5ae41e3121efb1e2bae5441e2ce40ec752f4c9a3f9c958ac15520844a50473764736f6c634300080d0033","opcodes":"PUSH1 0x56 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xA5 0xAE COINBASE 0xE3 SLT 0x1E 0xFB 0x1E 0x2B 0xAE SLOAD COINBASE 0xE2 0xCE BLOCKHASH 0xEC PUSH22 0x2F4C9A3F9C958AC15520844A50473764736F6C634300 ADDMOD 0xD STOP CALLER ","sourceMap":"740:2817:13:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;740:2817:13;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a5ae41e3121efb1e2bae5441e2ce40ec752f4c9a3f9c958ac15520844a50473764736f6c634300080d0033","opcodes":"PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xA5 0xAE COINBASE 0xE3 SLT 0x1E 0xFB 0x1E 0x2B 0xAE SLOAD COINBASE 0xE2 0xCE BLOCKHASH 0xEC PUSH22 0x2F4C9A3F9C958AC15520844A50473764736F6C634300 ADDMOD 0xD STOP CALLER ","sourceMap":"740:2817:13:-:0;;;;;;;;"},"gasEstimates":{"creation":{"codeDepositCost":"17200","executionCost":"103","totalCost":"17303"},"internal":{"clone(address)":"infinite","cloneDeterministic(address,bytes32)":"infinite","predictDeterministicAddress(address,bytes32)":"infinite","predictDeterministicAddress(address,bytes32,address)":"infinite"}},"legacyAssembly":{".code":[{"begin":740,"end":3557,"name":"PUSH #[$]","source":13,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":740,"end":3557,"name":"PUSH [$]","source":13,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"B"},{"begin":740,"end":3557,"name":"DUP3","source":13},{"begin":740,"end":3557,"name":"DUP3","source":13},{"begin":740,"end":3557,"name":"DUP3","source":13},{"begin":740,"end":3557,"name":"CODECOPY","source":13},{"begin":740,"end":3557,"name":"DUP1","source":13},{"begin":740,"end":3557,"name":"MLOAD","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"BYTE","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"73"},{"begin":740,"end":3557,"name":"EQ","source":13},{"begin":740,"end":3557,"name":"PUSH [tag]","source":13,"value":"1"},{"begin":740,"end":3557,"name":"JUMPI","source":13},{"begin":-1,"end":-1,"name":"PUSH","source":-1,"value":"4E487B71"},{"begin":-1,"end":-1,"name":"PUSH","source":-1,"value":"E0"},{"begin":-1,"end":-1,"name":"SHL","source":-1},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"MSTORE","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"4"},{"begin":740,"end":3557,"name":"MSTORE","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"24"},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"REVERT","source":13},{"begin":740,"end":3557,"name":"tag","source":13,"value":"1"},{"begin":740,"end":3557,"name":"JUMPDEST","source":13},{"begin":740,"end":3557,"name":"ADDRESS","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"MSTORE","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"73"},{"begin":740,"end":3557,"name":"DUP2","source":13},{"begin":740,"end":3557,"name":"MSTORE8","source":13},{"begin":740,"end":3557,"name":"DUP3","source":13},{"begin":740,"end":3557,"name":"DUP2","source":13},{"begin":740,"end":3557,"name":"RETURN","source":13}],".data":{"0":{".auxdata":"a2646970667358221220a5ae41e3121efb1e2bae5441e2ce40ec752f4c9a3f9c958ac15520844a50473764736f6c634300080d0033",".code":[{"begin":740,"end":3557,"name":"PUSHDEPLOYADDRESS","source":13},{"begin":740,"end":3557,"name":"ADDRESS","source":13},{"begin":740,"end":3557,"name":"EQ","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"80"},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"40"},{"begin":740,"end":3557,"name":"MSTORE","source":13},{"begin":740,"end":3557,"name":"PUSH","source":13,"value":"0"},{"begin":740,"end":3557,"name":"DUP1","source":13},{"begin":740,"end":3557,"name":"REVERT","source":13}]}}},"methodIdentifiers":{}},"ewasm":{"wasm":""},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as \\\"clones\\\". > To simply and cheaply clone contract functionality in an immutable way, this standard specifies > a minimal bytecode implementation that delegates all calls to a known, fixed address. The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2` (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the deterministic method. _Available since v3.4._\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts/proxy/Clones.sol\":\"Clones\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}
